package mk2driver

import (
	"bytes"
	"io"
	"testing"

	"github.com/stretchr/testify/assert"
)

var knownWrites = []byte{
	0x04, 0xff, 0x41, 0x01, 0x00, 0xbb,
	0x05, 0xff, 0x57, 0x36, 0x00, 0x00, 0x6f,
	0x05, 0xff, 0x57, 0x36, 0x01, 0x00, 0x6e,
	0x05, 0xff, 0x57, 0x36, 0x02, 0x00, 0x6d,
	0x05, 0xff, 0x57, 0x36, 0x03, 0x00, 0x6c,
	0x05, 0xff, 0x57, 0x36, 0x04, 0x00, 0x6b,
	0x05, 0xff, 0x57, 0x36, 0x05, 0x00, 0x6a,
	0x05, 0xff, 0x57, 0x36, 0x06, 0x00, 0x69,
	0x05, 0xff, 0x57, 0x36, 0x07, 0x00, 0x68,
	0x05, 0xff, 0x57, 0x36, 0x08, 0x00, 0x67,
	0x05, 0xff, 0x57, 0x36, 0x09, 0x00, 0x66,
	0x05, 0xff, 0x57, 0x36, 0x0a, 0x00, 0x65,
	0x05, 0xff, 0x57, 0x36, 0x0b, 0x00, 0x64,
	0x05, 0xff, 0x57, 0x36, 0x0c, 0x00, 0x63,
	0x05, 0xff, 0x57, 0x36, 0x0d, 0x00, 0x62,
	0x03, 0xff, 0x46, 0x00, 0xb8,
	0x03, 0xff, 0x46, 0x01, 0xb7,
	0x02, 0xff, 0x4c, 0xb3,
	0x05, 0xff, 0x57, 0x30, 0x0d, 0x00, 0x68,
}

var writeBuffer = bytes.NewBuffer(nil)

const (
	testEpsilon = 0.00000001
)

type testIo struct {
	io.Reader
	io.Writer
}

func NewIOStub(readBuffer []byte) io.ReadWriter {
	return &testIo{
		Reader: bytes.NewBuffer(readBuffer),
		Writer: writeBuffer,
	}
}

// Test a know sequence as reference as extracted from Mk2
func TestSync(t *testing.T) {
	knownReadBuffer := []byte{
		//Len  Cmd
		0x04, 0xff, 0x41, 0x01, 0x00, 0xbb, 0x07, 0xff, 0x56, 0x96, 0x3e, 0x11, 0x00, 0x00, 0xbf,
		0x08, 0xff, 0x57, 0x8e, 0x9c, 0x7f, 0x8f, 0x00, 0x00, 0x6a,
		0x08, 0xff, 0x57, 0x8e, 0x64, 0x80, 0x8f, 0x00, 0x00, 0xa1,
		0x08, 0xff, 0x57, 0x8e, 0x9c, 0x7f, 0x8f, 0x00, 0x00, 0x6a,
		0x08, 0xff, 0x57, 0x8e, 0x9c, 0x7f, 0x8f, 0x00, 0x00, 0x6a,
		0x08, 0xff, 0x57, 0x8e, 0x9c, 0x7f, 0x8f, 0x00, 0x00, 0x6a,
		0x08, 0xff, 0x57, 0x8e, 0x64, 0x80, 0x8f, 0x00, 0x00, 0xa1,
		0x08, 0xff, 0x57, 0x8e, 0x9c, 0x7f, 0x8f, 0x00, 0x00, 0x6a,
		0x08, 0xff, 0x57, 0x8e, 0x57, 0x78, 0x8f, 0x00, 0x01, 0xb5,
		0x08, 0xff, 0x57, 0x8e, 0x2f, 0x7c, 0x8f, 0x00, 0x00, 0xda,
		0x08, 0xff, 0x57, 0x8e, 0x64, 0x80, 0x8f, 0x00, 0x00, 0xa1,
		0x08, 0xff, 0x57, 0x8e, 0x04, 0x00, 0x8f, 0x00, 0x80, 0x01,
		0x08, 0xff, 0x57, 0x8e, 0x01, 0x00, 0x8f, 0x00, 0x80, 0x04,
		0x08, 0xff, 0x57, 0x8e, 0x02, 0x00, 0x8f, 0x00, 0x80, 0x03,
		0x08, 0xff, 0x57, 0x8e, 0x38, 0x7f, 0x8f, 0x00, 0x00, 0xce,
		0x07, 0xff, 0x56, 0x96, 0x3e, 0x11, 0x00, 0x00, 0xbf,
		0x0f, 0x20, 0xf3, 0x00, 0xc8, 0x02, 0x0c, 0xa1, 0x05, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x88, 0xb2,
		0x0f, 0x20, 0x01, 0x01, 0xca, 0x09, 0x08, 0xaa, 0x58, 0xab, 0x00, 0xaa, 0x58, 0x9a, 0x00, 0xc3, 0xe8,
		0x06, 0xff, 0x4c, 0x03, 0x00, 0x00, 0x00, 0xac,
		0x05, 0xff, 0x57, 0x85, 0xc8, 0x00, 0x58,
	}

	expectedLEDs := map[Led]LEDstate{
		LedMain:        LedOn,
		LedAbsorption:  LedOn,
		LedBulk:        LedOff,
		LedFloat:       LedOff,
		LedInverter:    LedOff,
		LedOverload:    LedOff,
		LedLowBattery:  LedOff,
		LedTemperature: LedOff,
	}
	testIO := NewIOStub(knownReadBuffer)
	mk2, err := NewMk2Connection(testIO)
	assert.NoError(t, err, "Could not open MK2")

	event := <-mk2.C()
	mk2.Close()

	assert.Equal(t, 0, bytes.Compare(writeBuffer.Bytes(), knownWrites), "Expected writes did not match received writes")
	assert.True(t, event.Valid, "data not valid")
	assert.Equal(t, uint32(2736), event.Version, "Invalid version decoded")
	assert.Equal(t, 0, len(event.Errors), "Reported errors not empty")
	assert.Equal(t, expectedLEDs, event.LEDs, "Reported LEDs incorrect")

	assert.InEpsilon(t, 14.41, event.BatVoltage, testEpsilon, "BatVoltage conversion failed")
	assert.InEpsilon(t, -0.4, event.BatCurrent, testEpsilon, "BatCurrent conversion failed")
	assert.InEpsilon(t, 226.98, event.InVoltage, testEpsilon, "InVoltage conversion failed")
	assert.InEpsilon(t, 1.71, event.InCurrent, testEpsilon, "InCurrent conversion failed")
	assert.InEpsilon(t, 50.10256410256411, event.InFrequency, testEpsilon, "InFrequency conversion failed")
	assert.InEpsilon(t, 226.980, event.OutVoltage, testEpsilon, "OutVoltage conversion failed")
	assert.InEpsilon(t, 1.54, event.OutCurrent, testEpsilon, "OutCurrent conversion failed")
	assert.InEpsilon(t, 50.025510204081634, event.OutFrequency, testEpsilon, "OutFrequency conversion failed")
	assert.InEpsilon(t, 1, event.ChargeState, testEpsilon, "ChargeState conversion failed")
}

func Test_mk2Ser_scaleDecode(t *testing.T) {
	tests := []struct {
		name            string
		frame           []byte
		expectedScaling scaling
	}{
		{
			name:  "Valid scale",
			frame: []byte{0x57, 0x8e, 0x9c, 0x7f, 0x8f, 0x00, 0x00, 0x6a},
			expectedScaling: scaling{
				scale:     0.00013679890560875513,
				offset:    143,
				supported: true,
			},
		},
		{
			name:  "Unsupported frame",
			frame: []byte{0x57, 0x00},
			expectedScaling: scaling{
				supported: false,
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &mk2Ser{
				scales: make([]scaling, 0, ramVarMaxOffset),
				p:      NewIOStub([]byte{}),
			}
			m.scaleDecode(tt.frame)
			assert.Equal(t, 1, len(m.scales))
			assert.Equal(t, 1, m.scaleCount)
			assert.Equal(t, tt.expectedScaling.supported, m.scales[0].supported)
			if tt.expectedScaling.supported {
				assert.InEpsilon(t, tt.expectedScaling.offset, m.scales[0].offset, testEpsilon)
				assert.InEpsilon(t, tt.expectedScaling.scale, m.scales[0].scale, testEpsilon)
			}
		})
	}
}
